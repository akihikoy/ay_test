#!/usr/bin/python3
#Discrete parameter optimizer
import math,random

#Return a Boltzmann policy (probabilities of selecting each action)
def BoltzmannPolicy(tau, values):
  if len(values)==0: return []
  max_v= max(values)
  sum_v= 0.0
  for q in values:
    sum_v+= math.exp((q-max_v)/tau)
  if sum_v<1.0e-10:
    return [1.0/float(len(values))]*len(values)
  probs= [0.0]*len(values)
  for d in range(len(values)):
    probs[d]= math.exp((values[d]-max_v)/tau)/sum_v
  return probs

#Return a Boltzmann policy (probabilities of selecting each action), considering valid options.
#  valid_options: a set of valid options.  the probabilities of options that not contained in this set are zero.
def BoltzmannPolicy2(tau, values, valid_options):
  if len(valid_options)==0: return []
  max_v= max([values[o] for o in valid_options])
  sum_v= 0.0
  for o in valid_options:
    q= values[o]
    sum_v+= math.exp((q-max_v)/tau)
  if sum_v<1.0e-10:
    return [1.0/float(len(valid_options))]*len(values)
  probs= [0.0]*len(values)
  for o in valid_options:
    probs[o]= math.exp((values[o]-max_v)/tau)/sum_v
  return probs

#Return an action selected w.r.t. the policy (probabilities of selecting each action)
def SelectFromPolicy(probs):
  p= random.random()  #Random number in [0,1]
  action= 0
  for prob in probs:
    if p<=prob:  return action
    p-= prob
    action+= 1
  return action-1

def UpdateMean(mean, new_value, alpha):
  return alpha*new_value + (1.0-alpha)*mean
def UpdateSqMean(sqmean, new_value, alpha):
  return alpha*(new_value**2) + (1.0-alpha)*sqmean
def GetSTD(mean, sqmean):
  return math.sqrt(max(0.0,sqmean-mean**2))

#Optimizing a discrete parameter whose score can be a random number
class TProbDiscOpt:
  #N: Number of options
  def __init__(self, N, using_none_set=False):
    self.N= N
    self.Means= []
    self.SqMeans= []
    #Index of the parameter vector lastly selected.
    self.index= -1
    #Temparature parameter for the Boltzmann selection.
    self.BoltzmannTau= 0.1
    self.UCBNsd= 1.0
    self.Alpha= 0.2
    self.InitStdDev= 0.25
    #Set of options that take None score. If UsingNoneSet, an option included in this set is ignored.
    self.option_set= set(range(self.N))
    self.NoneSet= set()
    self.UsingNoneSet= using_none_set
    #Parameters for stop conditions:
    self.TolSameOpt= 5
    self.TolScore= 1.0e-6
    self.same_opt_cnt= 0
    self.prev_index= None
    self.score_mean= None
    self.score_sqmean= None

  def UCB(self):
    return [self.Means[d] + self.UCBNsd*GetSTD(self.Means[d], self.SqMeans[d]) for d in range(self.N)]

  #Initialize learner.  data: set to continue from previous state, generated by Save.
  def Init(self, data=None):
    self.index= -1
    self.same_opt_cnt= 0
    self.prev_index= None

  #Returns the latest selected parameter.
  def Param(self):
    if self.N>0 and self.index>=0:  return self.index
    return None

  #Return the best parameter, mean-score
  def Result(self):
    if self.UsingNoneSet:
      best_s,best_o= max([(self.Means[o], o) for o in self.option_set-self.NoneSet])
    else:
      best_s,best_o= max(list(zip(self.Means, list(range(self.N)))))
    return best_o, best_s

  def Stopped(self):
    if len(self.option_set-self.NoneSet)==0:  return True
    if self.same_opt_cnt>=self.TolSameOpt:  return True
    if self.score_mean is not None and self.score_sqmean is not None and GetSTD(self.score_mean,self.score_sqmean)<self.TolScore:  return True
    return False

  def Select(self):
    if len(self.Means)==0:
      self.Means= [0.0]*self.N
      self.SqMeans= [self.InitStdDev**2]*self.N
    ucb= self.UCB()
    if self.UsingNoneSet:
      probs= BoltzmannPolicy2(self.BoltzmannTau, ucb, self.option_set-self.NoneSet)
    else:
      probs= BoltzmannPolicy(self.BoltzmannTau, ucb)
    self.prev_index= self.index
    self.index= SelectFromPolicy(probs)
    if self.prev_index is not None and self.index==self.prev_index: self.same_opt_cnt+=1
    else:  self.same_opt_cnt= 0
    #print 'TProbDiscOpt:DEBUG: Index:%i UCB:%f' % (self.index,ucb[self.index])

  def Update(self,score):
    assert(self.index>=0)
    if score==None:
      self.NoneSet|=set([self.index])
    else:
      self.Means[self.index]= UpdateMean(self.Means[self.index], score, self.Alpha)
      self.SqMeans[self.index]= UpdateSqMean(self.SqMeans[self.index], score, self.Alpha)
      if self.score_mean==None:
        self.score_mean= 0.0
        self.score_sqmean= self.InitStdDev**2
      else:
        self.score_mean= UpdateMean(self.score_mean, score, self.Alpha)
        self.score_sqmean= UpdateSqMean(self.score_sqmean, score, self.Alpha)
      #print 'TProbDiscOpt:DEBUG: Index:%i Score:%f New-Mean:%f' % (self.index,score,self.Means[self.index])

  ##Save internal parameters as a dictionary.
  #def Save(self):
    #data= {}
    #data['n']= ToStdType(self.N)
    #data['means']= ToStdType(self.Means)
    #data['sqmeans']= ToStdType(self.SqMeans)
    #data['boltzmann_tau']= self.BoltzmannTau
    #data['ucb_nsd']= self.UCBNsd
    #data['alpha']= self.Alpha
    #data['init_std_dev']= self.InitStdDev
    #return copy.deepcopy(data)


if __name__=='__main__':
  def fobj(n):
    if 100<n and n<120:
      return 1.0-float((n-110)**2)/10.0

  it_count= 0
  disc_opt= TProbDiscOpt(N=200, using_none_set=True)
  disc_opt.InitStdDev= 0.5
  disc_opt.Init()
  while not disc_opt.Stopped():
    disc_opt.Select()
    x= disc_opt.Param()
    f= fobj(x)
    disc_opt.Update(f)
    it_count+= 1
    print(it_count,x,f)

  print(disc_opt.NoneSet)
  print(disc_opt.Result())



