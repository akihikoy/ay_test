//-------------------------------------------------------------------------------------------
/*! \file    angled_rect_3d.cpp
    \brief   Compute an angled rect of a 3D polygon.
    \author  Akihiko Yamaguchi, info@akihikoy.net
    \version 0.1
    \date    Apr.11, 2023

g++ -g -Wall -O2 -o angled_rect_3d.out angled_rect_3d.cpp -lopencv_core -lopencv_imgproc
*/
//-------------------------------------------------------------------------------------------
#include <opencv2/core/core.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <iostream>
#include <fstream>
//-------------------------------------------------------------------------------------------
// #define print(var) PrintContainer((var), #var"= ")
#define print(var) std::cout<<#var"= "<<(var)<<std::endl
//-------------------------------------------------------------------------------------------

int main(int argc, char**argv)
{
  float points[][3]= {{0.0341453,-0.0913219,0.986689},{0.032528,-0.0913194,0.986662},{0.0292936,-0.0913144,0.986608},{0.0276746,-0.0896856,0.98651},{0.0276746,-0.0896856,0.98651},{0.0244375,-0.0864288,0.986313},{0.0228194,-0.0848009,0.986215},{0.0228194,-0.0848009,0.986215},{0.0212001,-0.0815484,0.986046},{0.0212001,-0.0815484,0.986046},{0.0179658,-0.0782948,0.98585},{0.0179658,-0.0782948,0.98585},{0.0163479,-0.0750445,0.985681},{0.0163479,-0.0750445,0.985681},{0.0147317,-0.0734188,0.985583},{0.0147317,-0.0734188,0.985583},{0.0131158,-0.0717934,0.985485},{0.0131149,-0.0701703,0.985414},{0.0131149,-0.0701703,0.985414},{0.0131139,-0.0685474,0.985343},{0.0114986,-0.0669229,0.985245},{0.0114986,-0.0669229,0.985245},{0.0114977,-0.0653005,0.985174},{0.0114977,-0.0653005,0.985174},{0.0098828,-0.0636766,0.985076},{0.0098828,-0.0636766,0.985076},{0.00988209,-0.0620547,0.985005},{0.00988138,-0.060433,0.984934},{0.00826701,-0.05881,0.984836},{0.00826642,-0.0571889,0.984765},{0.00665297,-0.0571873,0.984738},{0.00665201,-0.0539458,0.984596},{0.00665057,-0.0490853,0.984384},{0.00826285,-0.047467,0.98434},{0.00826225,-0.0458474,0.984269},{0.00987427,-0.0442294,0.984225},{0.00987356,-0.0426103,0.984154},{0.00987284,-0.0409914,0.984083},{0.00987213,-0.0393728,0.984012},{0.0114837,-0.0377555,0.983968},{0.0114837,-0.0377555,0.983968},{0.013095,-0.0361383,0.983924},{0.013095,-0.0361383,0.983924},{0.0163174,-0.0329043,0.983836},{0.017927,-0.0296701,0.983722},{0.0195391,-0.0296709,0.983749},{0.0227603,-0.026438,0.983661},{0.0243724,-0.0264388,0.983688},{0.0243724,-0.0264388,0.983688},{0.0259846,-0.0264395,0.983715},{0.0275949,-0.0248232,0.983671},{0.0292072,-0.0248239,0.983698},{0.0292051,-0.0232071,0.983627},{0.0308173,-0.0232077,0.983654},{0.0324273,-0.0215916,0.98361},{0.0340396,-0.0215922,0.983637},{0.035652,-0.0215928,0.983663},{0.0372645,-0.0215934,0.98369},{0.0388743,-0.0199774,0.983646},{0.0388743,-0.0199774,0.983646},{0.0404839,-0.0183615,0.983602},{0.043709,-0.0183625,0.983656},{0.0485474,-0.018364,0.983737},{0.0485509,-0.0199807,0.983808},{0.0501639,-0.0199812,0.983835},{0.0517808,-0.0215987,0.983932},{0.0550076,-0.0215999,0.983986},{0.0582348,-0.0216011,0.98404},{0.0614623,-0.0216023,0.984093},{0.0630762,-0.0216029,0.98412},{0.0630762,-0.0216029,0.98412},{0.0646948,-0.023221,0.984218},{0.066309,-0.0232216,0.984245},{0.0663138,-0.0248395,0.984316},{0.0679282,-0.0248402,0.984343},{0.0695477,-0.026459,0.984441},{0.0711623,-0.0264597,0.984467},{0.0744027,-0.0296985,0.984663},{0.074408,-0.0313174,0.984734},{0.0760288,-0.0329376,0.984832},{0.0760398,-0.0361768,0.984974},{0.0760452,-0.0377968,0.985045},{0.0776611,-0.0377978,0.985072},{0.0776667,-0.0394181,0.985143},{0.0776667,-0.0394181,0.985143},{0.0776723,-0.0410385,0.985214},{0.0792885,-0.0410397,0.985241},{0.0792999,-0.0442814,0.985383},{0.0792999,-0.0442814,0.985383},{0.0793113,-0.0475241,0.985525},{0.080928,-0.0475254,0.985552},{0.0809339,-0.0491471,0.985623},{0.0809397,-0.0507691,0.985694},{0.0809572,-0.0556364,0.985907},{0.0809689,-0.0588825,0.986049},{0.0809864,-0.0637533,0.986263},{0.0793743,-0.0653756,0.986307},{0.07938,-0.0669999,0.986378},{0.07938,-0.0669999,0.986378},{0.0793914,-0.0702491,0.98652},{0.0761605,-0.0718701,0.986537},{0.076166,-0.0734952,0.986608},{0.0761715,-0.0751206,0.98668},{0.0761715,-0.0751206,0.98668},{0.0729452,-0.0783677,0.986768},{0.0713318,-0.0799915,0.986812},{0.071337,-0.0816176,0.986883},{0.0681096,-0.084866,0.986972},{0.0664957,-0.0864904,0.987016},{0.064877,-0.086488,0.986989},{0.064877,-0.086488,0.986989},{0.0632583,-0.0864857,0.986962},{0.0616442,-0.0881101,0.987006},{0.0600256,-0.0881077,0.986979},{0.06003,-0.0897347,0.98705},{0.0567928,-0.0897298,0.986996},{0.0551744,-0.0897274,0.986969},{0.053556,-0.0897249,0.986942},{0.0519415,-0.0913495,0.986986},{0.0487051,-0.0913445,0.986932},{0.047087,-0.0913419,0.986905},{0.047087,-0.0913419,0.986905},{0.0422332,-0.0913344,0.986824},{0.0389977,-0.0913294,0.98677}};

  cv::Vec3f normal(0.0166263, -0.0437018, -0.998906);
  std::vector<cv::Vec3f> poly(sizeof(points)/sizeof(points[0]));
  for(int ip(0),ip_end(poly.size()); ip<ip_end; ++ip)
    poly[ip]= cv::Vec3f(points[ip][0],points[ip][1],points[ip][2]);

  cv::Scalar center_0= cv::mean(poly);
  cv::Vec3f center(center_0[0],center_0[1],center_0[2]);

  for(int ip(0),ip_end(poly.size()); ip<ip_end; ++ip)
    poly[ip]-= center;

//   print(normal);
//   for(int ip(0),ip_end(poly.size()); ip<ip_end; ++ip)
//     std::cout<<poly[ip];
//   std::cout<<std::endl;

  cv::Vec3f ax1(1.0, 0.0, 0.0), ax2;
  ax2= normal.cross(ax1);

  std::vector<cv::Vec2f> poly2d(poly.size());
  for(int ip(0),ip_end(poly.size()); ip<ip_end; ++ip)
    poly2d[ip]= cv::Vec2f(ax1.dot(poly[ip]),ax2.dot(poly[ip]));

  cv::RotatedRect rect= cv::minAreaRect(poly2d);

  print(normal);
  print(center);
  // print(cv::mean(poly));
  print(ax1);
  print(ax2);
  print(rect.center);
  print(rect.size);
  print(rect.angle);

  std::vector<cv::Vec2f> rect2d(4);
  {
    float x(rect.center.x), y(rect.center.y), w(rect.size.width), h(rect.size.height);
    float c(std::cos(rect.angle/180.*M_PI)), s(std::sin(rect.angle/180.*M_PI));
    rect2d[0]= cv::Vec2f(x+0.5*w*c+0.5*h*s, y-0.5*w*s+0.5*h*c);
    rect2d[1]= cv::Vec2f(x-0.5*w*c+0.5*h*s, y+0.5*w*s+0.5*h*c);
    rect2d[2]= cv::Vec2f(x-0.5*w*c-0.5*h*s, y+0.5*w*s-0.5*h*c);
    rect2d[3]= cv::Vec2f(x+0.5*w*c-0.5*h*s, y-0.5*w*s-0.5*h*c);
  }

  std::vector<cv::Vec3f> poly2d_3d(poly.size());
  for(int ip(0),ip_end(poly2d.size()); ip<ip_end; ++ip)
    poly2d_3d[ip]= poly2d[ip][0]*ax1+poly2d[ip][1]*ax2;
  std::vector<cv::Vec3f> rect2d_3d(rect2d.size());
  for(int ip(0),ip_end(rect2d.size()); ip<ip_end; ++ip)
    rect2d_3d[ip]= rect2d[ip][0]*ax1+rect2d[ip][1]*ax2;

  {
    std::ofstream ofs("/tmp/poly3d.dat");
    for(int ip(0),ip_end(poly.size()); ip<ip_end; ++ip)
      ofs<<poly[ip][0]<<" "<<poly[ip][1]<<" "<<poly[ip][2]<<std::endl;
  }
  {
    std::ofstream ofs("/tmp/poly2d.dat");
    for(int ip(0),ip_end(poly2d.size()); ip<ip_end; ++ip)
      ofs<<poly2d[ip][0]<<" "<<poly2d[ip][1]<<std::endl;
  }
  {
    std::ofstream ofs("/tmp/rect2d.dat");
    for(int ip(0),ip_end(rect2d.size()); ip<ip_end; ++ip)
      ofs<<rect2d[ip][0]<<" "<<rect2d[ip][1]<<std::endl;
  }
  {
    std::ofstream ofs("/tmp/poly2d_3d.dat");
    for(int ip(0),ip_end(poly2d_3d.size()); ip<ip_end; ++ip)
      ofs<<poly2d_3d[ip][0]<<" "<<poly2d_3d[ip][1]<<" "<<poly2d_3d[ip][2]<<std::endl;
  }
  {
    std::ofstream ofs("/tmp/rect2d_3d.dat");
    for(int ip(0),ip_end(rect2d_3d.size()); ip<ip_end; ++ip)
      ofs<<rect2d_3d[ip][0]<<" "<<rect2d_3d[ip][1]<<" "<<rect2d_3d[ip][2]<<std::endl;
  }

  std::cerr<<"Plot by:"<<std::endl;
  std::cerr<<"qplot -x -3d /tmp/poly3d.dat w lp /tmp/poly2d.dat u 1:2:'(0)' w lp /tmp/rect2d.dat u 1:2:'(0)' w lp /tmp/poly2d_3d.dat w lp /tmp/rect2d_3d.dat w lp"<<std::endl;

  return 0;
}
//-------------------------------------------------------------------------------------------
