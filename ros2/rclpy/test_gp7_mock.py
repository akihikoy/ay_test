#!/usr/bin/python3
#\file    test_gp7_mock.py
#\brief   certain python script
#\author  Akihiko Yamaguchi, info@akihikoy.net
#\version 0.1
#\date    Jan.26, 2026
#GENERATED BY GEMINI AND NO REFACTORING YET

import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.qos import qos_profile_sensor_data
from sensor_msgs.msg import JointState
from control_msgs.action import FollowJointTrajectory
from trajectory_msgs.msg import JointTrajectoryPoint
from rclpy.duration import Duration
import time
import copy

class MockTester(Node):
    def __init__(self):
        super().__init__('mock_tester')

        # URDFで定義した関節名
        self.joint_names = [
            'joint_1_s', 'joint_2_l', 'joint_3_u',
            'joint_4_r', 'joint_5_b', 'joint_6_t'
        ]

        # 1. Subscriber
        # GenericSystemからのデータを受信
        self.current_positions = None
        self.sub = self.create_subscription(
            JointState,
            '/joint_states',
            self.cb_joint,
            qos_profile_sensor_data  # 念の為 Best Effort に変更
        )

        # 2. Action Client
        self.client = ActionClient(
            self,
            FollowJointTrajectory,
            '/joint_trajectory_controller/follow_joint_trajectory'
        )

        self.get_logger().info('初期化完了')

    def cb_joint(self, msg):
        try:
            name_map = {n: p for n, p in zip(msg.name, msg.position)}
            # 必要な全関節が揃っているかチェック
            self.current_positions = [name_map[n] for n in self.joint_names]
        except KeyError:
            # まだ全ての関節データが揃っていない場合などは無視
            pass

    def send_motion(self):
        # 接続待機
        if not self.client.wait_for_server(timeout_sec=5.0):
            self.get_logger().error('Action Serverが見つかりません')
            return

        # 現在値待機
        self.get_logger().info('現在値待機中...')
        while self.current_positions is None and rclpy.ok():
            # 【重要】ここで spin_once を呼ばないとコールバックが動かない！
            rclpy.spin_once(self, timeout_sec=0.1)

        start_pos = list(self.current_positions)
        self.get_logger().info(f'Start: {start_pos}')

        # ゴール作成 (往復)
        goal = FollowJointTrajectory.Goal()
        goal.trajectory.joint_names = self.joint_names

        # Point 1: 現在地 (t=0)
        p1 = JointTrajectoryPoint()
        p1.positions = copy.deepcopy(start_pos)
        p1.time_from_start = Duration(seconds=0).to_msg()

        # Point 2: 移動 (t=3s)
        p2 = JointTrajectoryPoint()
        target = copy.deepcopy(start_pos)
        target[0] += 0.5  # S軸
        target[2] += 0.3  # U軸
        p2.positions = target
        p2.time_from_start = Duration(seconds=3).to_msg()

        # Point 3: 戻る (t=6s)
        p3 = JointTrajectoryPoint()
        p3.positions = copy.deepcopy(start_pos)
        p3.time_from_start = Duration(seconds=6).to_msg()

        goal.trajectory.points = [p1, p2, p3]

        # 送信
        self.get_logger().info('送信中...')
        future = self.client.send_goal_async(goal)

        # アクションの結果待ち中も spin が必要
        # rclpy.spin_until_future_complete は内部で spin してくれるのでOK
        rclpy.spin_until_future_complete(self, future)
        goal_handle = future.result()

        if not goal_handle.accepted:
            self.get_logger().error('拒否されました')
            return

        self.get_logger().info('実行中...')
        res_future = goal_handle.get_result_async()
        rclpy.spin_until_future_complete(self, res_future)

        result = res_future.result()
        self.get_logger().info(f'完了: 結果コード {result.result.error_code}')

def main():
    rclpy.init()
    node = MockTester()
    try:
        node.send_motion()
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
